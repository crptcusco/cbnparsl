import itertools

from satispy import Variable  # Library to resolve SAT
from satispy.solver import Minisat  # Library to resolve SAT
from itertools import product
from parsl import python_app
import re  # profiler_analysis of regular expressions
import operator  # unary operator management
from string import ascii_lowercase, ascii_uppercase  # import the list of uppercase and lowercase letters
from itertools import product  # generate combinations of numbers
from collections import namedtuple  # structures like trees
import random   # Aleatory numbers


class CBN:
    def __init__(self, l_local_networks,
                 l_directed_edges):
        # basic attributes
        self.l_local_networks = l_local_networks
        self.l_directed_edges = l_directed_edges

        self.n_local_networks = len(self.l_local_networks)
        self.i_attractor = 1

        # calculated attributes
        self.l_global_scenes = None
        self.d_local_attractors = None
        self.d_attractor_pair = None
        self.l_attractor_fields = None

        # graphs
        self.global_graph = None  # A networkx Graph object to make the visualizations
        self.d_network_color = {}  # Dictionary with the colors
        self.generate_local_nets_colors()  # Generate the colors for every local network
        self.detailed_graph = None  # Under Construction

    @staticmethod
    @python_app
    def find_local_attractors_task(o_local_network,
                                   l_local_scenes):
        from classes.localscene import LocalScene
        from classes.localnetwork import LocalNetwork

        print('=' * 80)
        print("Find Attractors for Local Network:", o_local_network.index)
        if l_local_scenes is None:
            o_local_scene = LocalScene(index=1)
            o_local_scene.l_attractors = LocalNetwork.find_local_scene_attractors(o_local_network, scene=None)
            o_local_network.l_local_scenes.append(o_local_scene)
        else:
            v_cont_index = 1
            for scene in l_local_scenes:
                o_local_scene = LocalScene(v_cont_index, scene, o_local_network.l_var_exterm)
                s_scene = ''.join(scene)
                o_local_scene.l_attractors = LocalNetwork.find_local_scene_attractors(o_local_network, s_scene)
                o_local_network.l_local_scenes.append(o_local_scene)
                v_cont_index = v_cont_index + 1
        return o_local_network

    @staticmethod
    def find_local_attractors_parsl(local_networks):
        tasks = []
        for local_network in local_networks:
            l_local_scenes = None
            if len(local_network.l_var_exterm) != 0:
                l_local_scenes = list(product(list('01'), repeat=len(local_network.l_var_exterm)))
            tasks.append(CBN.find_local_attractors_task(local_network, l_local_scenes))
        return tasks

    @staticmethod
    @python_app
    def find_compatible_pairs_task(o_cbn,
                                   o_output_signal):
        # o_output_signal.show()
        # begin functions
        l_attractors_input_0 = o_output_signal.d_out_value_to_attractor[0]
        l_attractors_input_1 = o_output_signal.d_out_value_to_attractor[1]
        l_pairs_edge_0 = []
        l_pairs_edge_1 = []

        # print("-------------------------------")
        # print("INPUT ATTRACTOR LIST")
        # search the values for every signal
        for signal_value in o_output_signal.d_out_value_to_attractor.keys():
            print("-------------------------------")
            print("Coupling signal value :", signal_value)
            # find the attractors that generated by this signal
            l_attractors_output = []
            # select the attractor who generated the output value of the signal
            for o_attractor in o_cbn.get_attractors_by_input_signal_value(o_output_signal.index_variable,
                                                                          signal_value):
                l_attractors_output.append(o_attractor)
                o_attractor.show()
            if signal_value == 0:
                l_pairs_edge_0 = list(itertools.product(l_attractors_input_0, l_attractors_output))
            elif signal_value == 1:
                l_pairs_edge_1 = list(itertools.product(l_attractors_input_1, l_attractors_output))
        # Join the two list in only one
        o_output_signal.d_comp_pairs_attractors_by_value[0] = l_pairs_edge_0
        o_output_signal.d_comp_pairs_attractors_by_value[1] = l_pairs_edge_1
        # print(l_pairs_edge_0)
        # print(l_pairs_edge_1)
        return o_output_signal

    @staticmethod
    def find_compatible_pairs_parsl(o_cbn):
        CustomText.print_duplex_line()
        print("FIND COMPATIBLE ATTRACTOR PAIRS")

        # generate the pairs using the output signal
        tasks = []
        for o_output_signal in o_cbn.l_directed_edges:
            task = CBN.find_compatible_pairs_task(o_cbn, o_output_signal)
            tasks.append(task)

        return tasks

    def mount_stable_attractor_fields_parsl(self):
        """
        Assembles compatible attractor fields.

        Args:
          List of compatible attractor pairs.

        Returns:
          List of attractor fields.
        """

        # Define una función Parsl para evaluar la compatibilidad de pares de atractores
        @python_app
        def evaluate_pair(base_pairs, candidate_pair):
            """
            Checks if a candidate attractor pair is compatible with a base attractor pair.

            Args:
              base_pairs: Base attractor pairs.
              candidate_pair: Candidate attractor pair.

            Returns:
              Boolean value of True or False.
            """

            # Extract the RDDs from each attractor pair.
            base_attractor_pairs = [attractor for pair in base_pairs for attractor in pair]

            # generate the already networks visited
            l_already_networks = {o_attractor.network_index for o_attractor in base_attractor_pairs}

            # Check if any RDD from the candidate attractor pair is present in the RDDs from the base attractor pair.
            double_check = sum(1 for candidate_attractor in candidate_pair
                               if candidate_attractor.network_index in l_already_networks
                               and candidate_attractor in base_attractor_pairs)

            return double_check == 2

        # Define una función Parsl para procesar un par de candidatos y agregarlos a la lista de campos de atracción
        @python_app
        def process_pair(base_pair, candidate_pair):
            if isinstance(base_pair, tuple):
                base_pair = [base_pair]
            if evaluate_pair(base_pair, candidate_pair):
                new_pair = base_pair + [candidate_pair]
                return new_pair
            else:
                return None

        def cartesian_product_mod_parallel(base_pairs, candidate_pairs):
            """
            Performs the modified Cartesian product of the attractor pairs lists.

            Args:
              base_pairs: List of base attractor pairs.
              candidate_pairs: List of candidate attractor pairs.

            Returns:
              List of candidate attractor fields.
            """

            # Initialize the list of futures
            futures = []

            # Procesa cada par de candidatos en paralelo utilizando Parsl
            for base_pair in base_pairs:
                for candidate_pair in candidate_pairs:
                    future = process_pair(base_pair, candidate_pair)
                    futures.append(future)

            # Espera a que se completen todas las tareas de Parsl y obtiene los resultados
            field_pair_list = [task.result() for task in futures]

            # Filtra los resultados nulos y devuelve la lista final
            return [result for result in field_pair_list if result is not None]

        CustomText.print_duplex_line()
        print("FIND ATTRACTOR FIELDS")

        # Order the edges by compatibility
        self.order_edges_by_compatibility()

        # generate a base list of the pairs
        l_base = self.l_directed_edges[:2]

        # generate the list of pairs made with 0 or 1
        l_base_pairs = l_base[0].d_comp_pairs_attractors_by_value[0] + l_base[0].d_comp_pairs_attractors_by_value[1]

        # for every edge make the union to the base
        for o_directed_edge in self.l_directed_edges[1:]:
            l_candidate_pairs = o_directed_edge.d_comp_pairs_attractors_by_value[0] + \
                                o_directed_edge.d_comp_pairs_attractors_by_value[1]
            # join the base list with the new directed edge
            l_base_pairs = cartesian_product_mod_parallel(l_base_pairs, l_candidate_pairs)

        CustomText.print_simple_line()
        print("Number of attractor fields found:", len(l_base_pairs))
        self.l_attractor_fields = l_base_pairs


class DirectedEdge:
    def __init__(self, index, index_variable_signal, input_local_network, output_local_network, l_output_variables,
                 coupling_function):
        self.index = index
        self.index_variable = index_variable_signal
        self.input_local_network = input_local_network
        self.output_local_network = output_local_network
        self.l_output_variables = l_output_variables
        self.coupling_function = coupling_function

        # Calculated properties
        # True table for signal with the output variables
        self.true_table = self.process_true_table()
        # Dictionary for kind status of the signal
        self.d_kind_signal = {1: "RESTRICTED",
                              2: "NOT COMPUTE",
                              3: "STABLE",
                              4: "NOT STABLE"}
        # Defined the initial kind for every coupling signal
        self.kind_signal = 2
        # Dictionary for group the attractors by his output signal value
        self.d_out_value_to_attractor = {1: [], 0: []}
        # List of the compatible pair attractors
        self.d_comp_pairs_attractors_by_value = {0: [], 1: []}

    def show(self):
        # CustomText.print_simple_line()
        CustomText.make_sub_sub_title(f"Index Edge: {self.index} - "
                                      f"Relation: {self.output_local_network} -> {self.input_local_network} - "
                                      f"Variable: {self.index_variable}")
        print("Variables:", self.l_output_variables, ", Coupling Function:", self.coupling_function)
        print("Truth table:", self.true_table)
        print("Kind signal:", self.kind_signal,
              "-", self.d_kind_signal[self.kind_signal])

    def process_true_table(self):
        r_true_table = {}
        # print("Generating the True Table")
        # First we must understand the coupling signal
        # we will use regular expressions to recognize the boolean formula

        # TOKENIZATION
        # Regular expression matching optional whitespace followed by a token
        # (if group 1 matches) or an error (if group 2 matches).
        TOKEN_RE = re.compile(r'\s*(?:([A-Za-z01()~∧∨→↔])|(\S))')

        # Special token indicating the end of the input string.
        TOKEN_END = '<end of input>'

        def tokenize(s):
            """Generate tokens from the string s, followed by TOKEN_END."""
            for match in TOKEN_RE.finditer(s):
                token, error = match.groups()
                if token:
                    yield token
                else:
                    raise SyntaxError("Unexpected character {!r}".format(error))
            yield TOKEN_END

        # PARSING
        Constant = namedtuple('Constant', 'value')
        Variable = namedtuple('Variable', 'name')
        UnaryOp = namedtuple('UnaryOp', 'op operand')
        BinaryOp = namedtuple('BinaryOp', 'left op right')

        # Tokens representing Boolean constants (0=False, 1=True).
        CONSTANTS = '01'

        # Tokens representing variables.
        VARIABLES = set(ascii_lowercase) | set(ascii_uppercase)

        # Map from unary operator to function implementing it.
        UNARY_OPERATORS = {
            '~': operator.not_,
        }

        # Map from binary operator to function implementing it.
        BINARY_OPERATORS = {
            '∧': operator.and_,
            '∨': operator.or_,
            '→': lambda a, b: not a or b,
            '↔': operator.eq,
        }

        def parse(s):
            """Parse s as a Boolean expression and return the parse tree."""
            tokens = tokenize(s)  # Stream of tokens.
            token = next(tokens)  # The current token.

            def error(expected):
                # Current token failed to match, so raise syntax error.
                raise SyntaxError("Expected {} but found {!r}"
                                  .format(expected, token))

            def match(valid_tokens):
                # If the current token is found in valid_tokens, consume it
                # and return True. Otherwise, return False.
                nonlocal token
                if token in valid_tokens:
                    token = next(tokens)
                    return True
                else:
                    return False

            def term():
                # Parse a <Term> starting at the current token.
                t = token
                if match(VARIABLES):
                    return Variable(name=t)
                elif match(CONSTANTS):
                    return Constant(value=(t == '1'))
                elif match('('):
                    tree = disjunction()
                    if match(')'):
                        return tree
                    else:
                        error("')'")
                else:
                    error("term")

            def unary_expr():
                # Parse a <UnaryExpr> starting at the current token.
                t = token
                if match('~'):
                    operand = unary_expr()
                    return UnaryOp(op=UNARY_OPERATORS[t], operand=operand)
                else:
                    return term()

            def binary_expr(parse_left, valid_operators, parse_right):
                # Parse a binary expression starting at the current token.
                # Call parse_left to parse the left operand; the operator must
                # be found in valid_operators; call parse_right to parse the
                # right operand.
                left = parse_left()
                t = token
                if match(valid_operators):
                    right = parse_right()
                    return BinaryOp(left=left, op=BINARY_OPERATORS[t], right=right)
                else:
                    return left

            def implication():
                # Parse an <Implication> starting at the current token.
                return binary_expr(unary_expr, '→↔', implication)

            def conjunction():
                # Parse a <Conjunction> starting at the current token.
                return binary_expr(implication, '∧', conjunction)

            def disjunction():
                # Parse a <Disjunction> starting at the current token.
                return binary_expr(conjunction, '∨', disjunction)

            tree = disjunction()
            if token != TOKEN_END:
                error("end of input")
            return tree

        def evaluate(tree, env):
            """Evaluate the expression in the parse tree in the context of an
            environment mapping variable names to their values.
            """
            if isinstance(tree, Constant):
                return tree.value
            elif isinstance(tree, Variable):
                return env[tree.name]
            elif isinstance(tree, UnaryOp):
                return tree.op(evaluate(tree.operand, env))
            elif isinstance(tree, BinaryOp):
                return tree.op(evaluate(tree.left, env), evaluate(tree.right, env))
            else:
                raise TypeError("Expected tree, found {!r}".format(type(tree)))

        # we have to create a dictionary for each variable in the output set
        l_abecedario = list(ascii_uppercase)

        dict_aux_var_saida = {}
        cont_aux_abecedario = 0
        for variable_saida in self.l_output_variables:
            dict_aux_var_saida[" " + str(variable_saida) + " "] = l_abecedario[cont_aux_abecedario]
            cont_aux_abecedario = cont_aux_abecedario + 1

        # generate combinations of the output signal
        l_permutations = []
        for v_permutacion in product([True, False], repeat=len(self.l_output_variables)):
            l_permutations.append(v_permutacion)

        # process each of the permutations we simply have to evaluate and solve
        for c_permutation in l_permutations:
            aux_dictionary = dict(zip(dict_aux_var_saida.values(), c_permutation))
            aux_acoplament_function = self.coupling_function
            for aux_element in dict_aux_var_saida.keys():
                aux_acoplament_function = aux_acoplament_function.replace(str(aux_element),
                                                                          str(dict_aux_var_saida[aux_element]))
            # print("========= Signal =========")
            # print(aux_acoplament_function)
            # print(dict_aux_var_saida)
            # print(aux_dictionary)
            # print("========= End Signal =========")
            # Creating the key of the truth table
            aux_key = ''
            for v_literal in c_permutation:
                if v_literal:
                    aux_key = aux_key + "1"
                else:
                    aux_key = aux_key + "0"
            if evaluate(parse(aux_acoplament_function), aux_dictionary):
                r_true_table[aux_key] = "1"
            else:
                r_true_table[aux_key] = "0"

        # print the true table
        # print(r_true_table)
        # sys.exit()

        return r_true_table

    def show_dict_v_output_signal_attractor(self):
        for signal_value, l_attractors in self.d_out_value_to_attractor.items():
            print(signal_value, "-", l_attractors)

    def show_v_output_signal_attractor(self):
        for signal_value, l_attractors in self.d_out_value_to_attractor.items():
            print("Output signal Value -", signal_value, "- Attractors:")
            for o_attractor in l_attractors:
                o_attractor.show()

    # def show_d_comp_pairs_attractors_by_value(self, value):
    #     self.d_comp_pairs_attractors_by_value()
    #


# VARIABLE MODEL ONLY HAVE VARIABLE_NAME, CNF FUNCTION
class InternalVariable:
    index = 0
    cnf_function = []

    def __init__(self, index, cnf_function):
        self.index = int(index)
        self.cnf_function = cnf_function

    def show(self):
        print("Variable Index: " + str(self.index) + " -> CNF :" + str(self.cnf_function))


class LocalNetwork:
    def __init__(self, num_local_network, l_var_intern):
        # basic properties
        self.index = num_local_network
        self.l_var_intern = l_var_intern

        # Processed properties
        self.des_funct_variables = []
        self.l_var_exterm = []
        self.l_var_total = []
        self.num_var_total = 0
        self.dic_var_cnf = {}

        self.l_input_signals = []
        self.l_output_signals = []

        # Calculated properties
        self.count_attractor = 1
        self.l_local_scenes = []

    def show(self):
        CustomText.make_sub_sub_title(f"Local Network: {self.index}")
        print('Internal Variables: ', self.l_var_intern)
        print('External Variables: ', self.l_var_exterm)
        print('Total Variables: ', self.l_var_total)
        # Description variables
        for o_internal_variable in self.des_funct_variables:
            o_internal_variable.show()

    def process_input_signals(self, l_input_signals):
        # Processing the input signals of local network
        for o_signal in l_input_signals:
            self.l_var_exterm.append(o_signal.index_variable)
        # add the local variables
        self.l_var_total.extend(self.l_var_intern.copy())
        # add the external variables from coupling signal
        self.l_var_total.extend(self.l_var_exterm.copy())
        # calculate the number of total variables
        self.num_var_total = len(self.l_var_total)

    def get_internal_variable(self, i_variable):
        for o_internal_variable in self.des_funct_variables:
            if o_internal_variable.index == i_variable:
                return o_internal_variable

    def update_internal_variable(self, o_internal_variable_to_update):
        for i, o_internal_variable in enumerate(self.des_funct_variables):
            if o_internal_variable.index == o_internal_variable_to_update.index:
                self.des_funct_variables[i] = o_internal_variable_to_update

    @staticmethod
    def find_local_attractors(o_local_network, l_local_scenes=None, count_attractor=1):
        CustomText.print_simple_line()
        print("FIND ATTRACTORS FOR NETWORK:", o_local_network.index)
        if l_local_scenes is None:
            o_local_scene = LocalScene(index=1)
            o_local_scene.l_attractors = LocalNetwork.find_local_scene_attractors(o_local_network=o_local_network,
                                                                                  scene=None,
                                                                                  count_attractor=count_attractor)
            o_local_network.l_local_scenes.append(o_local_scene)
        else:
            v_scene_index = 1
            for scene in l_local_scenes:
                o_local_scene = LocalScene(v_scene_index, scene, o_local_network.l_var_exterm)
                s_scene = ''.join(scene)
                o_local_scene.l_attractors = LocalNetwork.find_local_scene_attractors(o_local_network=o_local_network,
                                                                                      scene=s_scene,
                                                                                      count_attractor=count_attractor)
                o_local_network.l_local_scenes.append(o_local_scene)
                # update the scenes index
                v_scene_index = v_scene_index + 1
                # update the attractors index
                count_attractor += len(o_local_scene.l_attractors)

        o_local_network.count_attractor = count_attractor
        return o_local_network

    @staticmethod
    def gen_boolean_formulation(o_local_network, n_transitions, l_attractors_clauses, scene):
        # create dictionary of cnf variables!!
        for variable in o_local_network.l_var_total:
            for transition_c in range(0, n_transitions):
                o_local_network.dic_var_cnf[str(variable) + "_" + str(transition_c)] = Variable(
                    str(variable) + "_" + str(transition_c))

        cont_transition = 0
        boolean_function = Variable("0_0")
        for transition in range(1, n_transitions):
            cont_clause_global = 0
            boolean_expression_equivalence = Variable("0_0")
            for o_variable_model in o_local_network.des_funct_variables:
                cont_clause = 0
                boolean_expression_clause_global = Variable("0_0")
                for clause in o_variable_model.cnf_function:
                    boolean_expression_clause = Variable("0_0")
                    cont_term = 0
                    for term in clause:
                        term_aux = abs(int(term))
                        if cont_term == 0:
                            if str(term)[0] != "-":
                                boolean_expression_clause = o_local_network.dic_var_cnf[
                                    str(term_aux) + "_" + str(transition - 1)]
                            else:
                                boolean_expression_clause = -o_local_network.dic_var_cnf[
                                    str(term_aux) + "_" + str(transition - 1)]
                        else:
                            if str(term)[0] != "-":
                                boolean_expression_clause = o_local_network.dic_var_cnf[str(term_aux) + "_" + str(
                                    transition - 1)] | boolean_expression_clause
                            else:
                                boolean_expression_clause = -o_local_network.dic_var_cnf[
                                    str(term_aux) + "_" + str(transition - 1)] | boolean_expression_clause
                        cont_term = cont_term + 1
                    if cont_clause == 0:
                        boolean_expression_clause_global = boolean_expression_clause
                    else:
                        boolean_expression_clause_global = boolean_expression_clause_global & boolean_expression_clause
                    cont_clause = cont_clause + 1
                if cont_clause_global == 0:
                    boolean_expression_equivalence = o_local_network.dic_var_cnf[
                                                         str(o_variable_model.index) + "_" + str(
                                                             transition)] >> boolean_expression_clause_global
                    boolean_expression_equivalence = boolean_expression_equivalence & (
                            boolean_expression_clause_global >> o_local_network.dic_var_cnf[
                        str(o_variable_model.index) + "_" + str(transition)])
                else:
                    boolean_expression_equivalence = boolean_expression_equivalence & (o_local_network.dic_var_cnf[
                                                                                           str(o_variable_model.index) + "_" + str(
                                                                                               transition)] >> boolean_expression_clause_global)
                    boolean_expression_equivalence = boolean_expression_equivalence & (
                            boolean_expression_clause_global >> o_local_network.dic_var_cnf[
                        str(o_variable_model.index) + "_" + str(transition)])
                if not o_variable_model.cnf_function:
                    print("ENTER ATYPICAL CASE!!!")
                    boolean_function = boolean_function & (
                            o_local_network.dic_var_cnf[str(o_variable_model.index) + "_" + str(transition)] | -
                    o_local_network.dic_var_cnf[str(o_variable_model.index) + "_" + str(transition)])
                cont_clause_global = cont_clause_global + 1
            if cont_transition == 0:
                boolean_function = boolean_expression_equivalence
            else:
                boolean_function = boolean_function & boolean_expression_equivalence
            # validate blank gens
            cont_transition = cont_transition + 1

        # ASSIGN VALUES FOR PERMUTATIONS
        if scene is not None:
            cont_permutation = 0
            for element in o_local_network.l_var_exterm:
                # print oRDD.list_of_v_exterm
                for v_transition in range(0, n_transitions):
                    # print l_signal_coupling[cont_permutation]
                    if scene[cont_permutation] == "0":
                        boolean_function = boolean_function & -o_local_network.dic_var_cnf[
                            str(element) + "_" + str(v_transition)]
                        # print (str(element) +"_"+ str(v_transition))
                    else:
                        boolean_function = boolean_function & o_local_network.dic_var_cnf[
                            str(element) + "_" + str(v_transition)]
                        # print (str(element) +"_"+ str(v_transition))
                cont_permutation = cont_permutation + 1

        # add attractors to boolean function
        if len(l_attractors_clauses) > 0:
            boolean_function_of_attractors = Variable("0_0")
            cont_clause = 0
            for clause in l_attractors_clauses:
                bool_expr_clause_attractors = Variable("0_0")
                cont_term = 0
                for term in clause:
                    term_aux = abs(int(term))
                    if cont_term == 0:
                        if term[0] != "-":
                            bool_expr_clause_attractors = o_local_network.dic_var_cnf[
                                str(term_aux) + "_" + str(n_transitions - 1)]
                        else:
                            bool_expr_clause_attractors = -o_local_network.dic_var_cnf[
                                str(term_aux) + "_" + str(n_transitions - 1)]
                    else:
                        if term[0] != "-":
                            bool_expr_clause_attractors = bool_expr_clause_attractors & \
                                                          o_local_network.dic_var_cnf[
                                                              str(term_aux) + "_" + str(
                                                                  n_transitions - 1)]
                        else:
                            bool_expr_clause_attractors = bool_expr_clause_attractors & - \
                                o_local_network.dic_var_cnf[str(term_aux) + "_" + str(n_transitions - 1)]
                    cont_term = cont_term + 1
                if cont_clause == 0:
                    boolean_function_of_attractors = -bool_expr_clause_attractors
                else:
                    boolean_function_of_attractors = boolean_function_of_attractors & - bool_expr_clause_attractors
                cont_clause = cont_clause + 1
            boolean_function = boolean_function & boolean_function_of_attractors

        # Add all the variables of position 0 to the boolean function
        for variable in o_local_network.l_var_total:
            boolean_function = boolean_function & (o_local_network.dic_var_cnf[str(variable) + "_0"] |
                                                   - o_local_network.dic_var_cnf[str(variable) + "_0"])
        # print(boolean_function)
        return boolean_function

    @staticmethod
    def find_local_scene_attractors(o_local_network, scene=None, count_attractor=1):
        def count_state_repeat(v_estate, path_candidate):
            # input type [[],[],...[]]
            number_of_times = 0
            for v_element in path_candidate:
                if v_element == v_estate:
                    number_of_times = number_of_times + 1
            return number_of_times

        CustomText.print_simple_line()
        print("Network:", o_local_network.index, " Local Scene:", scene)

        # First obligatory execution
        set_of_attractors = []
        v_num_transitions = 3
        l_attractors = []
        l_attractors_clauses = []

        # create boolean expression initial with 3 transitions
        v_boolean_formulation = o_local_network.gen_boolean_formulation(o_local_network,
                                                                        v_num_transitions,
                                                                        l_attractors_clauses,
                                                                        scene)
        m_response_sat = []
        # Solve with SAT the boolean formulation
        o_solver = Minisat()
        o_solution = o_solver.solve(v_boolean_formulation)

        if o_solution.success:
            for j in range(0, v_num_transitions):
                m_response_sat.append([])
                for i in o_local_network.l_var_total:
                    m_response_sat[j].append(o_solution[o_local_network.dic_var_cnf[f'{i}_{j}']])

        m_aux_sat = []
        if len(m_response_sat) != 0:
            # TRANSFORM BOOLEAN TO MATRIZ BOOLEAN RESPONSE
            for j in range(0, v_num_transitions):
                matriz_aux_sat = []
                for i in range(0, o_local_network.num_var_total):
                    if m_response_sat[j][i]:
                        matriz_aux_sat.append("1")
                    else:
                        matriz_aux_sat.append("0")
                m_aux_sat.append(matriz_aux_sat)
            # m_resp_boolean = m_aux_sat
        m_resp_boolean = m_aux_sat
        # BLOCK ATTRACTORS
        # REPEAT CODE

        while len(m_resp_boolean) > 0:
            path_solution = []
            for path_transition in m_resp_boolean:
                path_solution.append(path_transition)

            # new list of state attractors
            l_news_estates_attractor = []
            # check attractors
            for v_state in path_solution:
                v_state_count = count_state_repeat(v_state, path_solution)
                if v_state_count > 1:
                    attractor_begin = path_solution.index(v_state) + 1
                    attractor_end = path_solution[attractor_begin:].index(v_state)
                    l_news_estates_attractor = path_solution[attractor_begin - 1:(attractor_begin + attractor_end)]
                    l_attractors = l_attractors + l_news_estates_attractor
                    # add attractors like list of list
                    set_of_attractors.append(l_news_estates_attractor)
                    break

            # print set_of_attractors
            if len(l_news_estates_attractor) == 0:
                # print ("duplicating")
                v_num_transitions = v_num_transitions * 2

            # TRANSFORM LIST OF ATTRACTORS TO CLAUSES
            for clause_attractor in l_attractors:
                clause_variable = []
                cont_variable = 0
                for estate_attractor in clause_attractor:
                    if estate_attractor == "0":
                        clause_variable.append("-" + str(o_local_network.l_var_total[cont_variable]))
                    else:
                        clause_variable.append(str(o_local_network.l_var_total[cont_variable]))
                    cont_variable = cont_variable + 1
                l_attractors_clauses.append(clause_variable)

            # print l_attractors_clauses
            # REPEAT CODE
            v_boolean_formulation = o_local_network.gen_boolean_formulation(o_local_network, v_num_transitions,
                                                                            l_attractors_clauses, scene)
            m_response_sat = []
            o_solver = Minisat()
            o_solution = o_solver.solve(v_boolean_formulation)

            if o_solution.success:
                for j in range(0, v_num_transitions):
                    m_response_sat.append([])
                    for i in o_local_network.l_var_total:
                        m_response_sat[j].append(o_solution[o_local_network.dic_var_cnf[f'{i}_{j}']])
            # else:
            #     # print(" ")
            #     print("The expression cannot be satisfied")

            # BLOCK ATTRACTORS
            m_aux_sat = []
            if len(m_response_sat) != 0:
                # TRANSFORM BOOLEAN TO MATRIZ BOOLEAN RESPONSE
                for j in range(0, v_num_transitions):
                    matriz_aux_sat = []
                    for i in range(0, o_local_network.num_var_total):
                        if m_response_sat[j][i]:
                            matriz_aux_sat.append("1")
                        else:
                            matriz_aux_sat.append("0")
                    m_aux_sat.append(matriz_aux_sat)
                # m_resp_boolean = m_aux_sat
            m_resp_boolean = m_aux_sat
            # BLOCK ATTRACTORS
            # REPEAT CODE

        # Creating the objects of the attractor
        l_scene_attractors = []
        v_index = 1
        for o_attractor in set_of_attractors:
            l_local_states = []
            for o_state in o_attractor:
                o_local_state = LocalState(o_state)
                l_local_states.append(o_local_state)
            o_local_attractor = LocalAttractor(count_attractor, v_index, l_local_states, o_local_network.index,
                                               o_local_network.l_var_exterm, scene)
            l_scene_attractors.append(o_local_attractor)
            # update the attractors index locally
            v_index += 1
            # update the attractors index globally
            count_attractor += 1

        print("end find attractors")
        return l_scene_attractors


class LocalScene:
    def __init__(self, index, l_values=None, l_index_signals=None):
        self.index = index
        self.l_values = l_values
        self.l_index_signals = l_index_signals
        # Calculated properties
        self.l_attractors = []


class LocalAttractor:
    def __init__(self, g_index, index, l_states, network_index, relation_index=None, local_scene=None):
        # base properties
        self.g_index = g_index
        self.index = index
        self.l_states = l_states
        # extended properties
        self.network_index = network_index
        self.relation_index = relation_index
        self.local_scene = local_scene

    def show(self):
        print("Network Index:", self.network_index, ", Input Signal Index:", self.relation_index,
              ", Scene:", self.local_scene, ", Attractor Index:", self.index, ", States:", end="")
        for o_state in self.l_states:
            print(end='[')
            for variable in o_state.l_variable_values:
                print(variable, end=",")
            print(end=']')
        print()

    def show_short(self):
        print("Net. Index:", self.network_index, ", Attrac. Index:", self.index, ", States:", end="")
        for o_state in self.l_states:
            print(end='[')
            for variable in o_state.l_variable_values:
                print(variable, end=",")
            print(end=']')
        print()


class LocalState:
    def __init__(self, l_variable_values):
        self.l_variable_values = l_variable_values


class PathCircleTemplate:
    def __init__(self, n_var_network, d_variable_cnf_function, l_output_var_indexes):
        self.n_var_network = n_var_network
        self.d_variable_cnf_function = d_variable_cnf_function
        self.l_output_var_indexes = l_output_var_indexes

    def show(self):
        print("Template for Path and Circle CBNs")
        print("-" * 80)
        print("Local dynamic:")
        for key, value in self.d_variable_cnf_function.items():
            print(key, ":", value)
        print("Output variables for the coupling signal:")
        print(self.l_output_var_indexes)

    @staticmethod
    def generate_aleatory_template(n_var_network, n_input_variables=2, n_output_variables=2):
        """
        Generates aleatory template for a local network
        :param n_output_variables:
        :param n_input_variables:
        :param n_var_network:
        :return: Dictionary of cnf function for variable and list of exit variables
        """

        # basic properties
        l_internal_var_indexes = list(range(n_var_network + 1, (n_var_network * 2) + 1))
        l_output_var_indexes = random.sample(range(1, n_var_network + 1), n_output_variables)
        l_input_coupling_signal_indexes = [n_var_network * 2 + 1]

        # calculate properties
        l_var_total_indexes = l_internal_var_indexes + l_input_coupling_signal_indexes

        # generate the aleatory dynamic
        d_variable_cnf_function = {}

        # select the internal variables that are going to have external variables
        internal_vars_for_external = random.sample(l_internal_var_indexes, n_input_variables)

        # generate cnf function for every internal variable
        for i_variable in l_internal_var_indexes:
            # evaluate if the variable is in internal_vars_for_external
            if i_variable in internal_vars_for_external:
                external_flag = False
                while not external_flag:
                    d_variable_cnf_function[i_variable] = [random.sample(l_var_total_indexes, 3)]
                    if any(element in d_variable_cnf_function[i_variable][0] for element in
                           l_input_coupling_signal_indexes):
                        external_flag = True
            else:
                # generate cnf function without external variables
                d_variable_cnf_function[i_variable] = [random.sample(l_internal_var_indexes, 3)]

            # apply negation randomly
            d_variable_cnf_function[i_variable][0] = [
                -element if random.choice([True, False]) else element for element
                in d_variable_cnf_function[i_variable][0]]

        # Generate the object of PathCircleTemplate
        o_path_circle_template = PathCircleTemplate(n_var_network, d_variable_cnf_function, l_output_var_indexes)
        return o_path_circle_template

    def get_output_variables_from_template(self, i_local_network, l_local_networks):
        # select the internal variables
        l_variables = []
        for o_local_network in l_local_networks:
            if o_local_network.index == i_local_network:
                # select the specific variables from variable list intern
                for position in self.l_output_var_indexes:
                    l_variables.append(o_local_network.l_var_intern[position - 1])

        return l_variables

    def update_clause_from_template(self, l_local_networks, o_local_network, i_local_variable, l_directed_edges,
                                    v_topology):
        """
        update clause from template
        :param l_directed_edges:
        :param v_topology:
        :param l_local_networks:
        :param o_local_network:
        :param i_local_variable:
        :return: l_clauses_node
        """

        l_indexes_directed_edges = []
        for o_directed_edge in l_directed_edges:
            l_indexes_directed_edges.append(o_directed_edge.index_variable)

        # find the correct cnf function for the variables
        n_local_variables = len(l_local_networks[0].l_var_intern)
        i_template_variable = i_local_variable - ((o_local_network.index - 1) * n_local_variables) + n_local_variables
        pre_l_clauses_node = self.d_variable_cnf_function[i_template_variable]

        print("Local Variable index:", i_local_variable)
        print("Template Variable index:", i_template_variable)
        print("CNF Function:", pre_l_clauses_node)

        # for every pre-clause update the variables of the cnf function
        l_clauses_node = []
        for pre_clause in pre_l_clauses_node:
            # update the number of the variable
            l_clause = []
            for template_value in pre_clause:
                # evaluate if the topology is linear(4) and is the first local network and not in the list of dictionary
                if (v_topology == 4 and o_local_network.index == 1
                        and abs(template_value) not in list(self.d_variable_cnf_function.keys())):
                    continue
                else:
                    # save the symbol (+ or -) of the value True for "+" and False for "-"
                    b_symbol = True
                    if template_value < 0:
                        b_symbol = False
                    # replace the value with the variable index
                    local_value = abs(template_value) + (
                            (o_local_network.index - 3) * n_local_variables) + n_local_variables
                    # analyzed if the value is an external value,searching the value in the list of intern variables
                    if local_value not in o_local_network.l_var_intern:
                        # print(o_local_network.l_var_intern)
                        # print(o_local_network.l_var_exterm)
                        # print(local_value)
                        local_value = o_local_network.l_var_exterm[0]
                    # add the symbol to the value
                    if not b_symbol:
                        local_value = -local_value
                    # add the value to the local clause
                    l_clause.append(local_value)

            # add the clause to the list of clauses
            l_clauses_node.append(l_clause)

        print(i_local_variable, ":", l_clauses_node)
        return l_clauses_node

    def generate_local_dynamic_with_template(self, l_local_networks, l_directed_edges, v_topology):
        """
        GENERATE THE DYNAMICS OF EACH LOCAL NETWORK
        :param v_topology:
        :param l_local_networks:
        :param l_directed_edges:
        :return: l_local_networks updated
        """
        number_max_of_clauses = 2
        number_max_of_literals = 3

        # generate an auxiliary list to modify the variables
        l_local_networks_updated = []

        # update the dynamic for every local network
        for o_local_network in l_local_networks:
            CustomText.print_simple_line()
            print("Local Network:", o_local_network.index)

            # find the directed edges by network index
            l_input_signals_by_network = CBN.find_input_edges_by_network_index(index=o_local_network.index,
                                                                               l_directed_edges=l_directed_edges)

            # # add the variable index of the directed edges
            # for o_signal in l_input_signals_by_network:
            #     o_local_network.l_var_exterm.append(o_signal.index_variable)
            # o_local_network.l_var_total = o_local_network.l_var_intern + o_local_network.l_var_exterm

            # generate the function description of the variables
            des_funct_variables = []
            # generate clauses for every local network adapting the template
            for i_local_variable in o_local_network.l_var_intern:
                CustomText.print_simple_line()
                # adapting the clause template to the specific variable
                l_clauses_node = self.update_clause_from_template(l_local_networks=l_local_networks,
                                                                  o_local_network=o_local_network,
                                                                  i_local_variable=i_local_variable,
                                                                  l_directed_edges=l_directed_edges,
                                                                  v_topology=v_topology)
                # generate an internal variable from satispy
                o_variable_model = InternalVariable(index=i_local_variable,
                                                    cnf_function=l_clauses_node)
                # adding the description in functions of every variable
                des_funct_variables.append(o_variable_model)

            # adding the local network to a list of local networks
            o_local_network.des_funct_variables = des_funct_variables.copy()
            l_local_networks_updated.append(o_local_network)
            print("Local network created :", o_local_network.index)
            CustomText.print_simple_line()

        # actualized the list of local networks
        return l_local_networks_updated

    def generate_cbn_from_template(self, v_topology, n_local_networks):
        """
        Generate a special CBN

        Args:
            v_topology: The topology of the CBN cam be 'linear' or 'ring'
            n_local_networks: The number of local networks
        Returns:
            A CBN generated from a template
        """

        # generate the local networks with the indexes and variables (without relations or dynamics)
        l_local_networks = CBN.generate_local_networks_indexes_variables(n_local_networks=n_local_networks,
                                                                         n_var_network=self.n_var_network)

        # generate the directed edges between the local networks
        l_directed_edges = []

        # generate the CBN topology
        l_relations = CBN.generate_global_topology(n_nodes=n_local_networks,
                                                   v_topology=v_topology)

        # Get the last index of the variables for the indexes of the directed edges
        i_last_variable = l_local_networks[-1].l_var_intern[-1] + 1

        # generate the directed edges given the last variable generated and the selected output variables
        for relation in l_relations:
            output_local_network = relation[0]
            input_local_network = relation[1]

            # get the output variables from template
            l_output_variables = self.get_output_variables_from_template(output_local_network,
                                                                         l_local_networks)

            # generate the coupling function
            coupling_function = " " + " ∨ ".join(list(map(str, l_output_variables))) + " "
            # generate the Directed-Edge object
            o_directed_edge = DirectedEdge(index_variable_signal=i_last_variable,
                                           input_local_network=input_local_network,
                                           output_local_network=output_local_network,
                                           l_output_variables=l_output_variables,
                                           coupling_function=coupling_function)
            i_last_variable += 1
            # add the directed-edge object to the list
            l_directed_edges.append(o_directed_edge)

        # Process the coupling signals for every local network
        for o_local_network in l_local_networks:
            # find the signals for every local network
            l_input_signals = CBN.find_input_edges_by_network_index(index=o_local_network.index,
                                                                    l_directed_edges=l_directed_edges)
            # process the input signals of the local network
            o_local_network.process_input_signals(l_input_signals=l_input_signals)

        # generate dynamic of the local networks with template
        l_local_networks = self.generate_local_dynamic_with_template(l_local_networks=l_local_networks,
                                                                     l_directed_edges=l_directed_edges,
                                                                     v_topology=v_topology)

        # generate the special coupled boolean network
        o_special_cbn = CBN(l_local_networks=l_local_networks,
                            l_directed_edges=l_directed_edges)

        return o_special_cbn


class CustomText:
    @staticmethod
    def print_duplex_line():
        print("=================================================")

    @staticmethod
    def print_simple_line():
        print("-"*50)

    @staticmethod
    def print_message(message, show):
        if show:
            print(message)

    @staticmethod
    def print_stars(cls):
        print("*************************************************")

    @staticmethod
    def print_dollars(cls):
        print(50 * '$')

    @staticmethod
    def make_principal_title(title):
        print(50 * '$')
        print(title.upper())

    @staticmethod
    def make_title(title):
        print(50 * '*')
        print(title.upper())

    @staticmethod
    def make_sub_title(sub_title):
        print(50 * '=')
        print(sub_title.upper())

    @staticmethod
    def make_sub_sub_title(sub_sub_title):
        print(50 * '-')
        print(sub_sub_title)


